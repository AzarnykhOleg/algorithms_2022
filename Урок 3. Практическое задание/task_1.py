"""
Задание 1.

Реализуйте функции:

a) заполнение списка, оцените сложность в O-нотации
   заполнение словаря, оцените сложность в O-нотации
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени

b) получение элемента списка, оцените сложность в O-нотации
   получение элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, откуда элемент получить быстрее и почему
   сделайте замеры времени

с) удаление элемента списка, оцените сложность в O-нотации
   удаление элемента словаря, оцените сложность в O-нотации
   сделайте аналитику, что где элемент удаляется быстрее и почему
   сделайте замеры времени


ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time
from random import sample, randrange


# Декоратор для расчёта времени работы функции
def time_of_function(function):
    def wrapped(*args):
        start_time = time.perf_counter()
        res = function(*args)
        print(f'Время работы функции "{function.__name__}" - {time.perf_counter() - start_time}')
        return res

    return wrapped


# A-1. Функция для заполнения списка n элементами
@time_of_function
def filling_lst(n):  # O(n)
    lst = sample(range(1, 100000), n)  # O(n)
    return lst  # O(1)


# A-2. Функция для заполнения словаря n элементами
@time_of_function
def filling_dict(n):  # O(n)
    dct = {}  # O(1)
    for k in range(n):  # O(n)
        k = randrange(1, 1000000)  # O(1)
        v = 2 * k  # O(1)
        dct[k] = v  # O(1)
    return dct  # O(1)


"""
    Если я правильно оценил работу функций randomr.randrange и 
range  (О(1)),  работа  функций по заполнению словаря и списка 
работают с "условно" одинаковой скоростью - O(n).
    При этом замеры времени в большинстве (но не во всех) случаев
были  в  пользу  списка (незначительно). Думаю, что это связано с 
количеством строк кода, не учитываемых в приблизительных рассчётах 
в  O-нотации, или особенностями записи элементов словаря (проверка 
ключей, например).
"""


# В-1. Функция для получения элемента списка
@time_of_function
def get_lst(lst, n):  # O(1)
    el = lst[n]  # O(1)
    return el  # O(1)


# В-2. Функция для получения элемента словаря
@time_of_function
def get_dct(dct, k):  # O(1)
    el = dct[k]  # O(1)
    return el  # O(1)


"""
   Работа  функций по получению элемента списка и получению элемента 
словаря работают с "условно" одинаковой скоростью - O(n). При этом 
замеры времени во всех случаях были в пользу словаря. В причине не
разобрался... Вроде бы обе операции "стоят" одинаково.
"""


# В-1. Функция для удаления элемента списка
@time_of_function
def del_lst(lst, n):  # O(n)
    el = lst.pop(n)  # O(n)
    return el  # O(1)


# В-2. Функция для удаления элемента словаря
@time_of_function
def del_dct(dct, k):  # O(1)
    el = dct.pop(k, None)  # O(1)
    return el  # O(1)


"""
   Явное преимущество словаря. В отличие от списка, после удаления
элемента в словаре не происходит смещения последующих элементов
к началу списка и присвоение им обновлённых индексов.
"""


# Работа функции для заполнения списка элементами
print(filling_lst(5000))
# Работа функции для заполнения словаря элементами
print(filling_dict(5000))
# Работа функции для для получения элемента списка
lst = [87264, 81922, 84729, 26304, 80230, 30592, 74353, 15611, 17923, 33055,
       35156, 56829, 17513, 85193, 56251, 11651, 51230, 87555, 56404, 36682]
print(get_lst(lst, 10))
# Работа функции для для получения элемента словаря
dct = {341197: 682394, 411053: 822106, 340920: 681840, 609862: 1219724, 425196: 850392, 334013: 668026,
       694909: 1389818, 795479: 1590958, 662964: 1325928, 545485: 1090970, 395467: 790934, 268877: 537754,
       70362: 140724, 144276: 288552, 829418: 1658836, 938043: 1876086, 145099: 290198, 576036: 1152072,
       496323: 992646, 71062: 142124}
print(get_dct(dct, 662964))
# Работа функции для для удаления элемента списка
print(del_lst(lst, 10))
# Работа функции для для удаления элемента словаря
print(del_dct(dct, 662964))
